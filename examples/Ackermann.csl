
plus(zero, Y) -> Y
plus(succ(X), Y) -> plus(X, succ(Y))

alpha(X, zero) -> zero
alpha(X, succ(zero)) -> succ(zero)
alpha(X, Y) -> X

ackermann(X, Y, zero) -> plus(X, Y)
ackermann(X, zero, succ(Z)) -> alpha(X, Z)
ackermann(X, succ(Y), succ(Z)) -> ackermann(X, ackermann(X, Y, succ(Z)), Z)

MARKING {
  input: succ(succ(zero))
}

TRANSITION compute {
  MATCH {
    input: X
  }
  PRODUCE {
    output: ackermann(X, X, X)
  }
}